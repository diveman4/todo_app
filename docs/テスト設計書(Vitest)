テスト設計書：TODOアプリ 画面テスト（Vitest）

1. テスト概要
対象機能: フロントエンド TODO アプリ TodoPage コンポーネント（/ ページ）
目的: 画面単体レベルで、TODO 一覧表示・新規作成・編集・削除・完了トグル・初期表示（永続化前提の取得処理）が、UI と API 呼び出しの観点で正しく動作することを確認する
テスト種別: コンポーネントテスト（Vitest + React Testing Library）

2. 前提条件
環境
vitest が実行可能なフロントエンド開発環境
TodoPage が @/app/page として正しくインポートできること
API モジュール @/lib/api の以下関数がモック可能であること
fetchTodos
createTodo
updateTodo
deleteTodo
ドロワー等のレイアウト系コンポーネント（@/components/Drawer, @/components/MaterialMode）はテスト内でモックされている
データ前提
モック TODO データとして、以下 2 件が fetchTodos の返却値として事前に定義されている
ID: 1 / タイトル: 「買い物に行く」 / completed: false
ID: 2 / タイトル: 「勉強する」 / completed: true（取り消し線が付く想定）
テスト実行前処理
各テストケースの beforeEach で vi.resetAllMocks() 済み
fetchTodos は毎回 mockResolvedValue(mockTodos) でモックされている
TodoPage を render(<TodoPage />) し、fetchTodos が呼ばれるまで waitFor で待機する共通 setup 関数を利用

3. テスト観点・項目
T-01 TODO一覧表示・完了状態の表示（取り消し線の有無）
T-02 新規作成（タイトル必須 + 追加時に API 呼び出し & 一覧への反映）
T-03 タイトル編集（インライン編集 + 更新 API 呼び出し）
T-04 削除（確認ダイアログ + 削除 API 呼び出し）
T-05 完了/未完了トグル（チェック状態と API 呼び出し）
T-06 データ永続化観点（初期表示時にバックエンドから取得していること）

4. テストケース詳細
T-01 TODO一覧表示・完了状態の表示
事前条件
setup 済み（fetchTodos がモックデータを返却済み）
手順
TodoPage をレンダリングする（setup() を呼び出す）。
画面上に「買い物に行く」「勉強する」というテキストが表示されているかを確認する。
completed = true の TODO（「勉強する」）要素のクラス名に、取り消し線を表すクラス（line-through を含む）が設定されているかを確認する。
期待結果
手順 2:
「買い物に行く」「勉強する」がそれぞれ screen.getByText で取得できる（= DOM 上に存在する）。
手順 3:
「勉強する」要素の className に line-through が含まれており、完了状態が見た目で表現されている。

T-02 新規作成（タイトル必須 + API 呼び出し & 一覧への反映）
事前条件
setup 済み
手順
タイトル入力欄（プレースホルダ「新しいTODOを入力...」）を取得する。
「追加」ボタンを取得する。
入力欄が空の状態で「追加」ボタンの活性状態を確認する。
入力欄に「新しいタスク」と入力する。
「追加」ボタンが有効（enabled）になっていることを確認する。
createTodo を { title: "新しいタスク", description: undefined, dueDate: undefined, priority: "MEDIUM" } で呼んだ際に、新しい TODO（ID: 3, タイトル: 「新しいタスク」）を返すようにモックする。
「追加」ボタンをクリックする。
waitFor で createTodo が期待どおりの引数で呼ばれたこと、および画面上に「新しいタスク」が表示されていることを確認する。
期待結果
手順 3:
タイトル未入力のとき、「追加」ボタンは toBeDisabled() で検証できる状態（無効）になっている。
手順 5:
「新しいタスク」と入力後、「追加」ボタンが not.toBeDisabled() となり有効化される。
手順 8:
createTodo が一度呼ばれ、引数は
title: "新しいタスク"
description: undefined
dueDate: undefined
priority: "MEDIUM"
である。
画面上に「新しいタスク」というテキストを持つ TODO が表示されている。

T-03 タイトル編集（インライン編集 + 更新 API 呼び出し）
事前条件
setup 済み
updateTodo が、ID 1 の TODO タイトルを「買い物に行く（編集後）」に変更したオブジェクトを返すようにモックされている
手順
「編集」ボタンのうち、先頭のもの（ID 1 対象）を取得する。
「編集」ボタンをクリックし、対象行を編集モードにする。
既存タイトル「買い物に行く」が入力されたインライン編集用のテキストボックスを取得する。
テキストボックスの値を「買い物に行く（編集後）」に変更する。
「保存」ボタンをクリックする。
waitFor で updateTodo が (1, { title: "買い物に行く（編集後）" }) で呼ばれたことを確認する。
画面上のタイトル表示が「買い物に行く（編集後）」に更新されていることを確認する。
期待結果
手順 3:
「買い物に行く」が初期値として入力されたテキストボックスが取得できる。
手順 6:
updateTodo が ID 1, 更新内容 { title: "買い物に行く（編集後）" } で一度呼び出される。
手順 7:
一覧上に「買い物に行く（編集後）」というテキストが表示され、旧タイトルが置き換わっている。

T-04 削除（確認ダイアログ + 削除 API 呼び出し）
事前条件
setup 済み
window.confirm が true を返すモックに差し替えられている
deleteTodo が正常終了するよう mockResolvedValue() でモックされている
手順
window.confirm を vi.spyOn(window, "confirm") でモックし、常に true を返すようにする。
先頭の TODO 行に対応する「削除」ボタンを取得する。
「削除」ボタンをクリックする。
waitFor により、以下を確認する。
window.confirm が「本当に削除しますか？」というメッセージで呼ばれていること。
deleteTodo が ID 1 を引数に呼ばれていること。
期待結果
手順 4:
confirmMock が一度呼ばれ、メッセージは「本当に削除しますか？」である。
deleteTodo が一度呼ばれ、引数は 1（対象 TODO の ID）である。
（画面上からの消失までは E2E でカバーされる前提だが、本テストでは API 呼び出しまでを主に検証）

T-05 完了/未完了トグル（チェック状態と API 呼び出し）
事前条件
setup 済み
updateTodo が、ID 1 の completed を true に変更したオブジェクトを返すようモックされている
手順
一覧の先頭行に対応するチェックボックス要素を取得する。
初期状態でチェックボックスがオフ（not.toBeChecked()）であることを確認する。
チェックボックスをクリックする。
waitFor で updateTodo が (1, { completed: true }) で呼ばれたことを確認する。
期待結果
手順 2:
初期状態では先頭のチェックボックスが未チェックである。
手順 4:
updateTodo が ID 1, { completed: true } の引数で一度呼ばれる。
チェック操作に応じて完了状態更新 API が正しく発火していることが確認できる。

T-06 データ永続化観点（初期表示時にバックエンドから取得されること）
事前条件
特になし（setup 内で fetchTodos をモックしている）
手順
setup() を呼び出し、TodoPage を初期表示する。
fetchTodos の呼び出し回数を確認する。
期待結果
手順 2:
fetchTodos が 1 回呼び出されている（toHaveBeenCalledTimes(1)）。
初期表示時にバックエンド（モック）から TODO 一覧を取得する処理が実装されていることが確認できる。